// Generated by CoffeeScript 1.9.1
(function() {
  var R, bind, cartesianProduct, multiDim,
    slice = [].slice;

  R = rx.rxt.tags;

  bind = rx.bind;

  window.multiDim = multiDim = function(arg) {
    var accum, cellData, cellFn, cellOptsFn, colArgs, colWidths, cols, fmtfn, indexedCellData, numCols, numRows, rowArgs, rowHeights, rows, tableOpts;
    rowArgs = arg.rowArgs, colArgs = arg.colArgs, cellFn = arg.cellFn, cellOptsFn = arg.cellOptsFn, tableOpts = arg.tableOpts, cellData = arg.cellData, fmtfn = arg.fmtfn;
    if (tableOpts == null) {
      tableOpts = {};
    }
    if (cellOptsFn == null) {
      cellOptsFn = function() {
        return {};
      };
    }
    if (cellData == null) {
      cellData = null;
    }
    if (fmtfn == null) {
      fmtfn = _.identity;
    }
    if (cellFn == null) {
      cellFn = function() {
        return "";
      };
    }
    numCols = _.reduce(colArgs, function(memo, arg1) {
      var values;
      values = arg1.values;
      return memo * values.length;
    }, 1);
    numRows = _.reduce(rowArgs, function(memo, arg1) {
      var values;
      values = arg1.values;
      return memo * values.length;
    }, 1);
    accum = numCols;
    colWidths = colArgs.map(function(arg1) {
      var values;
      values = arg1.values;
      return accum /= values.length;
    });
    accum = numRows;
    rowHeights = rowArgs.map(function(arg1) {
      var values;
      values = arg1.values;
      return accum /= values.length;
    });
    rows = cartesianProduct.apply(null, rowArgs.map(function(arg1) {
      var name, values;
      name = arg1.name, values = arg1.values;
      return values.map(function(value) {
        return {
          name: name,
          value: value
        };
      });
    }));
    cols = cartesianProduct.apply(null, colArgs.map(function(arg1) {
      var name, values;
      name = arg1.name, values = arg1.values;
      return values.map(function(value) {
        return {
          name: name,
          value: value
        };
      });
    }));
    if (cellData) {
      indexedCellData = _.object(cellData.map(function(arg1) {
        var input, output;
        input = arg1.input, output = arg1.output;
        console.log(_.pluck(_.sortBy(input, 'name'), 'value'));
        return [JSON.stringify(_.pluck(_.sortBy(input, 'name'), 'value')), output];
      }));
    } else {
      indexedCellData = {};
    }
    return R.table(tableOpts, _.flatten([
      R.thead({}, _.flatten([
        R.tr(R.th({
          rowspan: colArgs.length * 2 + 1,
          colspan: rowArgs.length
        })), colArgs.map(function(arg1, ci) {
          var i, name, ref, results, values;
          name = arg1.name, values = arg1.values;
          return [
            R.tr(_.flatten((function() {
              results = [];
              for (var i = 0, ref = numCols / (colWidths[ci] * values.length); 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
              return results;
            }).apply(this).map(function() {
              return values.map(function(argVal) {
                return R.th({
                  colspan: colWidths[ci]
                }, argVal);
              });
            })))
          ];
        })
      ])), R.tbody({}, rows.map(function(row, rowNum) {
        return R.tr({}, _.flatten([
          row.map(function(arg1, rowIndex) {
            var name, value;
            name = arg1.name, value = arg1.value;
            if (rowNum % rowHeights[rowIndex] === 0) {
              return R.th({
                rowspan: rowHeights[rowIndex]
              }, value);
            } else {
              return null;
            }
          }), cols.map(function(col) {
            var argDict, argString, argVals, cellVal;
            argVals = _.sortBy(row.concat(col), 'name');
            argString = JSON.stringify(_.pluck(argVals, 'value'));
            argDict = _.object(argVals.map(function(arg1) {
              var name, value;
              name = arg1.name, value = arg1.value;
              return [name, value];
            }));
            cellVal = argString in indexedCellData ? indexedCellData[argString] : cellFn(argDict);
            return R.td(_.extend({}, cellOptsFn(cellVal, argDict)), fmtfn(cellVal, argDict));
          })
        ]));
      }))
    ]));
  };

  cartesianProduct = function() {
    var lists, prod, r;
    lists = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (lists.length > 1) {
      r = [];
      prod = cartesianProduct.apply(null, lists.slice(1));
      lists[0].map(function(item) {
        return prod.map(function(product) {
          return r.push([item].concat(product));
        });
      });
      return r;
    } else {
      return lists[0].map(function(item) {
        return [item];
      });
    }
  };

}).call(this);

//# sourceMappingURL=main.js.map
