// Generated by CoffeeScript 1.9.1
(function() {
  var R, bind, cartesianProduct, multiDim,
    slice = [].slice;

  R = rx.rxt.tags;

  bind = rx.bind;

  window.multiDim = multiDim = function(arg) {
    var accum, cellFn, cellOptsFn, colArgs, colWidths, cols, numCols, numRows, rowArgs, rowHeights, rows, tableOpts;
    rowArgs = arg.rowArgs, colArgs = arg.colArgs, cellFn = arg.cellFn, cellOptsFn = arg.cellOptsFn, tableOpts = arg.tableOpts;
    if (tableOpts == null) {
      tableOpts = {};
    }
    if (cellOptsFn == null) {
      cellOptsFn = function() {
        return {};
      };
    }
    numCols = _.reduce(colArgs, function(memo, arg1) {
      var values;
      values = arg1.values;
      return memo * values.length;
    }, 1);
    numRows = _.reduce(rowArgs, function(memo, arg1) {
      var values;
      values = arg1.values;
      return memo * values.length;
    }, 1);
    accum = numCols;
    colWidths = colArgs.map(function(arg1) {
      var values;
      values = arg1.values;
      return accum /= values.length;
    });
    accum = numRows;
    rowHeights = rowArgs.map(function(arg1) {
      var values;
      values = arg1.values;
      return accum /= values.length;
    });
    rows = cartesianProduct.apply(null, rowArgs.map(function(arg1) {
      var name, values;
      name = arg1.name, values = arg1.values;
      return values.map(function(val) {
        return [name, val];
      });
    }));
    cols = cartesianProduct.apply(null, colArgs.map(function(arg1) {
      var name, values;
      name = arg1.name, values = arg1.values;
      return values.map(function(val) {
        return [name, val];
      });
    }));
    return R.table(tableOpts, _.flatten([
      R.thead({}, _.flatten([
        R.tr(R.th({
          rowspan: colArgs.length * 2 + 1,
          colspan: rowArgs.length
        })), colArgs.map(function(arg1, ci) {
          var i, name, ref, results, values;
          name = arg1.name, values = arg1.values;
          return [
            R.tr(_.flatten((function() {
              results = [];
              for (var i = 0, ref = numCols / (colWidths[ci] * values.length); 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
              return results;
            }).apply(this).map(function() {
              return values.map(function(argVal) {
                return R.th({
                  colspan: colWidths[ci]
                }, argVal);
              });
            })))
          ];
        })
      ])), R.tbody({}, rows.map(function(row, rowNum) {
        return R.tr({}, _.flatten([
          row.map(function(arg1, rowIndex) {
            var name, val;
            name = arg1[0], val = arg1[1];
            if (rowNum % rowHeights[rowIndex] === 0) {
              return R.th({
                rowspan: rowHeights[rowIndex]
              }, val);
            } else {
              return null;
            }
          }), cols.map(function(col) {
            var argVals;
            argVals = _.object(row.concat(col));
            return R.td(_.extend({}, cellOptsFn(argVals)), cellFn(argVals));
          })
        ]));
      }))
    ]));
  };

  cartesianProduct = _.memoize(function() {
    var lists, prod, r;
    lists = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (lists.length > 1) {
      r = [];
      prod = cartesianProduct.apply(null, lists.slice(1));
      lists[0].map(function(item) {
        return prod.map(function(product) {
          return r.push([item].concat(product));
        });
      });
      return r;
    } else {
      return lists[0].map(function(item) {
        return [item];
      });
    }
  });

}).call(this);

//# sourceMappingURL=main.js.map
